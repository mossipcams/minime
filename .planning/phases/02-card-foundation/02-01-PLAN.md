---
phase: 02-card-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types.ts
  - src/minime-card.ts
  - src/main.ts
  - tests/minime-card.test.ts
autonomous: true

must_haves:
  truths:
    - "Card registers as custom element 'minime-card' and can be instantiated"
    - "setConfig throws descriptive error when entity is missing or invalid"
    - "setConfig accepts valid config with entity string"
    - "getCardSize returns integer for masonry layout"
    - "render produces shadow DOM output without errors"
    - "disconnectedCallback cleans up without errors"
  artifacts:
    - path: "src/types.ts"
      provides: "MiniMeConfig interface and HomeAssistant type declarations"
      contains: "interface MiniMeConfig"
    - path: "src/minime-card.ts"
      provides: "LitElement card class with lifecycle methods"
      exports: ["MiniMeCard"]
    - path: "src/main.ts"
      provides: "Card registration with customElements.define and window.customCards"
      contains: "customElements.define"
    - path: "tests/minime-card.test.ts"
      provides: "Tests for config validation and card lifecycle"
      contains: "setConfig"
  key_links:
    - from: "src/main.ts"
      to: "src/minime-card.ts"
      via: "import and customElements.define"
      pattern: "customElements\\.define.*minime-card"
    - from: "src/minime-card.ts"
      to: "src/types.ts"
      via: "import MiniMeConfig"
      pattern: "import.*MiniMeConfig"
---

<objective>
Create the MiniMe card LitElement component with configuration validation, lifecycle methods, and custom element registration.

Purpose: Establishes the card shell that Home Assistant can discover and render. Without this foundation, no HA integration is possible.
Output: A registered custom element `minime-card` with setConfig validation, getCardSize, render skeleton, and disconnectedCallback.
</objective>

<execution_context>
@/Users/matt/.claude/get-shit-done/workflows/execute-plan.md
@/Users/matt/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/main.ts
@rollup.config.mjs
@tsconfig.json
@package.json
@vitest.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create types and card component with lifecycle methods</name>
  <files>src/types.ts, src/minime-card.ts</files>
  <action>
Create `src/types.ts` with:
- `MiniMeConfig` interface: `{ type: string; entity: string; name?: string; }` — entity is the Bermuda BLE device_tracker entity ID
- `HomeAssistant` type: Use the shape from custom-card-helpers or declare minimal interface with `{ states: Record<string, HassEntity>; themes: { darkMode: boolean }; }` and `HassEntity` with `{ state: string; attributes: Record<string, unknown>; entity_id: string; last_changed: string; last_updated: string; }`. Keep it minimal — only what we actually use. Do NOT import the full HomeAssistant type from custom-card-helpers (it pulls in heavy dependencies and causes bundling issues). Declare what we need locally.

Create `src/minime-card.ts` with a LitElement class `MiniMeCard`:

1. **Properties/State:**
   - `_config` as internal state (NOT @property, just a class field) storing MiniMeConfig
   - `_hass` as internal class field (NEVER @state or @property — critical pattern from research: making hass reactive causes re-render on EVERY entity change in HA)
   - `@state() _entityState: string | undefined` — just the extracted area/state string from the Bermuda entity
   - `@state() _error: string | undefined` — error message to display

2. **setConfig(config: MiniMeConfig):**
   - Throw `Error('Please define an entity')` if config.entity is missing/falsy
   - Throw `Error('Entity must be a device_tracker entity (e.g., device_tracker.bermuda_xxx)')` if entity doesn't start with `device_tracker.`
   - Store validated config in `this._config`

3. **set hass(hass: HomeAssistant):**
   - Store hass reference: `this._hass = hass`
   - Extract entity state: `const entity = hass.states[this._config.entity]`
   - If entity not found, set `this._error = 'Entity not found: ' + this._config.entity`
   - If entity found, clear error and set `this._entityState = entity.state` (this is the area name from Bermuda)
   - This selective extraction means the card only re-renders when the tracked entity's state actually changes

4. **getCardSize(): number** — return `3` (standard card height units for a visual card)

5. **render():**
   - If no config, return `html\`\`` (empty)
   - If error, return error display: `html\`<ha-card><div class="error">${this._error}</div></ha-card>\``
   - Normal state: return `html\`<ha-card header="${this._config.name || 'MiniMe'}"><div class="card-content"><div class="room-label">${this._entityState || 'Unknown'}</div></div></ha-card>\``
   - This is a skeleton render — Phase 3 replaces it with pixel art visuals

6. **static styles:** Basic CSS using `css\`\`` with:
   - `.card-content { padding: 16px; }`
   - `.room-label { font-size: 1.2em; text-align: center; }`
   - `.error { color: var(--error-color, red); padding: 16px; }`
   - Use HA CSS variables where possible (var(--primary-text-color), var(--card-background-color))

7. **disconnectedCallback():**
   - Call `super.disconnectedCallback()`
   - Future cleanup placeholder (animation frames, timers will be added in Phase 4)

Do NOT call `customElements.define` in this file — registration happens in main.ts.
  </action>
  <verify>Run `npx tsc --noEmit` — zero TypeScript errors. Verify both files exist and export correctly.</verify>
  <done>MiniMeCard class exists with setConfig (validation), set hass (selective extraction), getCardSize, render, disconnectedCallback. Types are defined locally. No TS errors.</done>
</task>

<task type="auto">
  <name>Task 2: Wire registration in main.ts and add tests</name>
  <files>src/main.ts, tests/minime-card.test.ts</files>
  <action>
Update `src/main.ts`:
- Import MiniMeCard from './minime-card'
- Register: `customElements.define('minime-card', MiniMeCard)`
- Add to window.customCards for HA card picker:
  ```
  (window as any).customCards = (window as any).customCards || [];
  (window as any).customCards.push({
    type: 'minime-card',
    name: 'MiniMe Card',
    description: 'Animated pixel art avatar showing your room presence',
  });
  ```
- Keep the existing version console.info logging

Replace `tests/sample.test.ts` with `tests/minime-card.test.ts` (delete the sample test file). Tests to write:

1. **Config validation tests:**
   - `it('throws when entity is missing')` — `expect(() => card.setConfig({} as any)).toThrow('Please define an entity')`
   - `it('throws when entity is not device_tracker')` — `expect(() => card.setConfig({ entity: 'sensor.foo' } as any)).toThrow('device_tracker')`
   - `it('accepts valid config')` — `expect(() => card.setConfig({ type: 'custom:minime-card', entity: 'device_tracker.bermuda_phone' })).not.toThrow()`

2. **Card size test:**
   - `it('returns card size for masonry layout')` — `expect(card.getCardSize()).toBe(3)`

3. **Hass setter test:**
   - `it('extracts entity state from hass')` — Create mock hass with states containing the entity, set it on card, verify _entityState matches
   - `it('sets error when entity not found')` — Set hass with empty states, verify _error is set

For test setup: Create `MiniMeCard` instance directly with `new MiniMeCard()`, call `setConfig()` with valid config before hass tests. Do NOT try to render in tests (happy-dom doesn't fully support shadow DOM/Lit rendering). Focus on unit testing the logic methods.

After writing tests, run `npm run build` to verify the production bundle builds successfully.
  </action>
  <verify>Run `npm test` — all tests pass. Run `npm run build` — dist/minime-card.js is created without errors. Verify the sample.test.ts file is deleted.</verify>
  <done>Card registers as 'minime-card' custom element. All 6 tests pass. Production build succeeds. Sample test removed.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npm test` passes all tests
- `npm run build` produces dist/minime-card.js
- The built JS file contains 'minime-card' registration string
</verification>

<success_criteria>
- MiniMeCard class implements setConfig, set hass, getCardSize, render, disconnectedCallback
- Config validation rejects missing entity and non-device_tracker entities with clear messages
- Card is registered as 'minime-card' custom element and listed in window.customCards
- All tests pass, build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/02-card-foundation/02-01-SUMMARY.md`
</output>
