---
phase: 03-static-visual-display
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/minime-card-editor.ts
  - src/types.ts
  - src/minime-card.ts
  - src/main.ts
  - tests/minime-card-editor.test.ts
autonomous: true

must_haves:
  truths:
    - "Visual editor renders entity picker for selecting Bermuda device tracker"
    - "Visual editor renders area multi-select for choosing which rooms to track"
    - "Editor dispatches config-changed events when user modifies settings"
    - "Card's getConfigElement() returns the editor custom element"
    - "Editor is registered as a separate custom element 'minime-card-editor'"
  artifacts:
    - path: "src/minime-card-editor.ts"
      provides: "Visual configuration editor component"
      exports: ["MiniMeCardEditor"]
    - path: "src/types.ts"
      provides: "Updated config type with areas field"
      contains: "areas"
    - path: "tests/minime-card-editor.test.ts"
      provides: "Tests for editor config changes and validation"
      contains: "config-changed"
  key_links:
    - from: "src/minime-card.ts"
      to: "src/minime-card-editor.ts"
      via: "getConfigElement returns editor element"
      pattern: "getConfigElement"
    - from: "src/minime-card-editor.ts"
      to: "config-changed event"
      via: "CustomEvent dispatch on value change"
      pattern: "config-changed"
    - from: "src/main.ts"
      to: "src/minime-card-editor.ts"
      via: "customElements.define registration"
      pattern: "minime-card-editor"
---

<objective>
Create the visual configuration editor component for the MiniMe card.

Purpose: Home Assistant users expect a visual editor for card configuration. Without it, users must manually write YAML, which is poor UX. The editor provides entity picker for Bermuda device selection and area multi-select for room configuration.
Output: A registered `minime-card-editor` custom element with entity picker and area selector that dispatches config-changed events.
</objective>

<execution_context>
@/Users/matt/.claude/get-shit-done/workflows/execute-plan.md
@/Users/matt/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
@src/types.ts
@src/minime-card.ts
@src/main.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update types and create editor component</name>
  <files>src/types.ts, src/minime-card-editor.ts</files>
  <action>
**Update `src/types.ts`:**
- Add `areas?: string[]` to `MiniMeConfig` interface — list of HA area IDs the user wants to track (e.g., ['office', 'kitchen', 'living_room', 'bedroom'])
- Add `name?: string` (already exists, keep it)
- Add `HomeAssistant` interface extension: add `areas: Record<string, { area_id: string; name: string; }>` to the HomeAssistant interface — HA provides area registry data
- Add `HassArea` interface: `{ area_id: string; name: string; picture?: string | null; }` — used by the area picker

**Create `src/minime-card-editor.ts`:**

A LitElement class `MiniMeCardEditor` implementing the HA card editor pattern:

1. **Properties:**
   - `public hass?: HomeAssistant` — HA sets this on the editor
   - `@state() private _config?: MiniMeConfig` — current card config

2. **setConfig(config: MiniMeConfig):**
   - Store config: `this._config = config`

3. **_valueChanged(ev: Event):**
   - Extract configValue and value from event target
   - Build new config with updated value
   - Dispatch `config-changed` CustomEvent: `new CustomEvent('config-changed', { detail: { config: newConfig }, bubbles: true, composed: true })`

4. **_areasChanged(ev: Event):**
   - Handle area multi-select changes
   - Extract selected area IDs from the event
   - Dispatch config-changed with updated areas array

5. **render():**
   - Render a form with:
     a. **Entity picker** using `<ha-entity-picker>`:
        ```html
        <ha-entity-picker
          .hass=${this.hass}
          .value=${this._config?.entity || ''}
          .configValue=${'entity'}
          .includeDomains=${['device_tracker']}
          @value-changed=${this._valueChanged}
          label="Bermuda Device Tracker"
          allow-custom-entity
        ></ha-entity-picker>
        ```
     b. **Name input** using standard text input:
        ```html
        <ha-textfield
          label="Card Name"
          .value=${this._config?.name || ''}
          .configValue=${'name'}
          @input=${this._valueChanged}
        ></ha-textfield>
        ```
        If ha-textfield is not reliably available, fall back to a standard `<input>` element wrapped in a div with label.
     c. **Area multi-select** — Since HA doesn't provide a built-in multi-select area picker as a custom element, implement as a set of checkboxes:
        - Query available areas from `this.hass` (HA exposes areas in various ways)
        - For simplicity, use a text input where user enters comma-separated area IDs, or hardcode the 4 known areas (office, kitchen, living_room, bedroom) as checkboxes
        - Each checkbox dispatches config-changed with updated areas array
        - Label: "Rooms to Track"

6. **static styles:** Basic editor styling:
   - `.editor-row { padding: 8px 0; }`
   - Labels and inputs properly spaced

The editor does NOT need to be fancy. Functional is sufficient for v1.

IMPORTANT: Do NOT use `@customElement` decorator — we register in main.ts. Export the class only.
  </action>
  <verify>Run `npx tsc --noEmit` — zero errors. Verify the editor class exports correctly and implements setConfig + render.</verify>
  <done>Editor component created with entity picker, name input, and area checkboxes. Config type updated with areas field. Editor dispatches config-changed events.</done>
</task>

<task type="auto">
  <name>Task 2: Wire editor registration and add tests</name>
  <files>src/minime-card.ts, src/main.ts, tests/minime-card-editor.test.ts</files>
  <action>
**Update `src/minime-card.ts`:**
- Add static `getConfigElement()` method that returns `document.createElement('minime-card-editor')`
- Add static `getStubConfig()` method that returns `{ entity: '', name: 'MiniMe', areas: ['office', 'kitchen', 'living_room', 'bedroom'] }` — default config for card picker

**Update `src/main.ts`:**
- Import `MiniMeCardEditor` from './minime-card-editor'
- Register: `customElements.define('minime-card-editor', MiniMeCardEditor)`
- Keep existing card registration as-is

**Create `tests/minime-card-editor.test.ts`:**

Tests for the editor component:

1. **Config handling:**
   - `it('stores config when setConfig called')` — verify _config is set
   - `it('accepts config with areas')` — verify areas array is stored

2. **Event dispatching:**
   - `it('dispatches config-changed event on entity change')` — Simulate calling _valueChanged with mock event containing configValue='entity' and value='device_tracker.new_device'. Listen for 'config-changed' event on the element. Verify event.detail.config.entity equals new value.

3. **getConfigElement integration:**
   - In minime-card.test.ts (or editor test), verify `MiniMeCard.getConfigElement()` returns an element with tagName 'MINIME-CARD-EDITOR'

Use the same test setup pattern as minime-card.test.ts: register custom element if not registered, create via document.createElement.

After tests pass, run `npm run build` to verify the editor is included in the bundle.
  </action>
  <verify>Run `npm test` — all tests pass (both card and editor tests). Run `npm run build` — bundle builds successfully and includes editor registration.</verify>
  <done>Editor registered as 'minime-card-editor', card exposes getConfigElement() and getStubConfig(). Editor tests pass. Build includes editor in bundle.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npm test` passes all tests (card tests still pass + new editor tests)
- `npm run build` produces bundle that includes both card and editor
- MiniMeCard.getConfigElement() returns an element
- Editor dispatches config-changed events
</verification>

<success_criteria>
- Visual editor component exists with entity picker and area configuration
- Editor dispatches config-changed events when user modifies settings
- Card exposes getConfigElement() returning the editor element
- Config type includes areas field for room tracking
- All tests pass, build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/03-static-visual-display/03-02-SUMMARY.md`
</output>
